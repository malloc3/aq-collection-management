{"config":{"title":"Collection_Management","description":"A group of libraries to assist with collections and using collections","copyright":"UW_BIOFAB","version":"0.0.1","authors":[{"name":"Cannon Mallory","affiliation":"UW_BIOFAB"},{"name":"Amy Cash","affilation":"","affiliation":"UW_BIOFAB"},{"name":"Justin Vrana","affilation":"","affiliation":"UW_BIOFAB"}],"maintainer":{"name":"Cannon Mallory","email":"malloc3@uw.edu"},"acknowledgements":null,"github":{"user":"malloc3","repo":"aq-collection-management"},"keywords":null,"aquadoc_version":"1.0.0","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"CollectionActions","category":"Collection_Management","code_source":"# frozen_string_literal: true\n\n# Cannon Mallory\n# malloc3@uw.edu\n#\n# Module for working with collections\n# These actions should involve the WHOLE plate not individual wells.\n# NOTE: The collection is doing the whole action\n\nneeds 'Standard Libs/ItemActions'\n\nmodule CollectionActions\n  include ItemActions\n\n  # Creates new collection.  Instructions to tech optional\n  #\n  # @param c_type [String] the collection type\n  # @param label_plate [Boolean] instructs tech to label if true\n  # @return working_plate [Collection]\n  def make_new_plate(c_type, label_plate: true)\n    working_plate = Collection.new_collection(c_type)\n    get_and_label_new_plate(working_plate) if label_plate\n    working_plate\n  end\n\n  # Makes the required number of collections and populates with samples\n  # returns an array of of collections created\n  #\n  # @param samples [Array\u003cFieldValue\u003e] or [Array\u003cSamples\u003e]\n  # @param collection_type [String] the type of collection that is to be made\n  # @param first_collection [Collection] optional a collection to start with\n  # @param add_column_wise [Boolean] default false add samples by column\n  # @param label_plates [Boolean] default false, provides instructions\n  # @return [Array\u003cCollection\u003e] array of collections created\n  def make_and_populate_collection(samples, collection_type: nil,\n                                   first_collection: nil,\n                                   add_column_wise: false,\n                                   label_plates: false)\n\n    if collection_type.nil? \u0026\u0026 first_collection.nil?\n      ProtocolError 'Either collection_type or first_collection must be given'\n    end\n\n    unless collection_type.nil? || first_collection.nil?\n      ProtocolError 'Both collection_type and first_collection cannot be given'\n    end\n\n    capacity = nil\n    if collection_type.nil?\n      collection_type = fisrt_collection.object_type.name\n      capacity = first_collection.capacity\n      remaining_space = first_collection.get_empty.length\n      add_samples_to_collection(samples[0...remaining_space - 1],\n                                first_collection,\n                                label_plates: label_plates,\n                                add_column_wise: add_column_wise)\n      samples = samples.drop(remaining_space)\n    else\n      obj_type = ObjectType.find_by_name(collection_type)\n      capacity = obj_type.columns * obj_type.rows\n    end\n\n    collections = []\n    collections.push(first_collection) unless first_collection.nil?\n    grouped_samples = samples.in_groups_of(capacity, false)\n    grouped_samples.each do |sub_samples|\n      collection = make_new_plate(collection_type, label_plate: label_plates)\n      add_samples_to_collection(sub_samples, collection, \n                                add_column_wise: add_column_wise)\n      collections.push(collection)\n    end\n    collections\n  end\n\n  # Assigns samples to specific well locations\n  #\n  # @param samples [Array\u003cFieldValue\u003e] or [Array\u003cSamples\u003e]\n  # @param to_collection [Collection]\n  # @param add_row_wise [Boolean] default false, will add samples by column\n  # @raise if not enough space in collection\n  def add_samples_to_collection(samples, to_collection, add_column_wise: false)\n    samples.map! do |fv|\n      unless fv.is_a?(Sample)\n        fv = fv.sample\n      end\n      fv\n    end\n\n    slots_left = to_collection.get_empty.length\n    raise 'Not enough space in in collection' if samples.length \u003e slots_left\n\n    if add_column_wise\n      add_samples_column_wise(samples, to_collection)\n    else\n      to_collection.add_samples(samples)\n    end\n    to_collection\n  end\n\n  # Adds samples to the first slot in the first available column\n  # as opposed to column wise that the base version does.\n  #\n  # @param samples_to_add [Array\u003cSamples\u003e] an array of samples\n  # @param collection [Collection] the collection to include samples\n  def add_samples_column_wise(samples_to_add, collection)\n    col_matrix = collection.matrix\n    columns = col_matrix.first.size\n    rows = col_matrix.size\n    samples_to_add.each do |sample|\n      break_pattern = false\n      columns.times do |col|\n        rows.times do |row|\n          if collection.part(row, col).nil?\n            collection.set(row, col, sample)\n            break_pattern = true\n            break\n          end\n        end\n        break if break_pattern\n      end\n    end\n  end\n\n  # Instructions on getting and labeling new plate\n  #\n  # @param plate [Collection] the plate to be retrieved and labeled\n  def get_and_label_new_plate(plate)\n    show do\n      title 'Get and Label Working Plate'\n      note \"Get a \u003cb\u003e#{plate.object_type.name}\u003c/b\u003e and\n           label it ID: \u003cb\u003e#{plate.id}\u003c/b\u003e\"\n    end\n  end\n\n  # Associates field_values to corresponding samples in a collection\n  # TODO not sure multiples of samples is handled in the best way...\n  #\n  # @param field_values [Array\u003cField Values\u003e] array of field values\n  # @param collection [Collection] the destination collection\n  # replaced make_output_plate\n  def associate_field_values_to_plate(field_values, collection)\n    already_associated_parts = []\n    field_values.each do |fv|\n      r_c = nil\n      collection.find(fv.sample).each do |loc|\n        r_c = loc\n        break unless already_associated_parts.include?(loc)\n      end\n      r_c = collection.find(fv.sample).first\n      unless r_c.nil?\n        fv.set(collection: collection, row: r_c[0], column: r_c[1])\n      end\n    end\n  end\nend\n"}},{"library":{"name":"CollectionData","category":"Collection_Management","code_source":"# CollectionData\n\nneeds 'Standard Libs/AssociationManagement'\n\n# for managing data associations of collections\n# and ensuring that samples/item data is handled correctly\nmodule CollectionData\n  include AssociationManagement\n  include PartProvenance\n\n  # Is this being used?\n  # Associates data to every part in a plate\n  #\n  # @param plate [Collection] the collection\n  # @param data [Anything] the data to be associated\n  def associate_to_all(plate:, data:, key:)\n    data_map = []\n    parts.each do |part|\n      loc = plate.find(part)\n      loc[2] = data\n      loc[3] = key\n      data_map.push(loc)\n    end\n    associate_value_key_to_parts(plate: plate, data_map: data_map)\n  end\n\n  # Creates table for the data associated with key\n  #\n  # @param collection [Collection] the plate being used\n  # @param keys [Array\u003cString\u003e] an array of keys that the data is\n  #        associated with.\n  # @return table of parts with data information\n\n  def display_all_data(collection, keys)\n    rc_list = []\n    parts = collection.parts\n    parts.each do |part|\n      rc_list += collection.find(part)\n    end\n    display_data(collection, rc_list, keys)\n  end\n\n  # Associates data in data_map to parts in plate.\n  #\n  # @param plate [Collection] the plate containing the Items\n  # @param data_map [Array\u003cArray\u003crow, column, value\u003e, ...\u003e] \n  #                                         determine where data goes\n  # @param key [String] the key that\n  def associate_value_to_parts(plate:, data_map:, key:)\n    data_map.each do |loc_val_array|\n      loc_val_array[3] = key\n    end\n    associate_value_key_to_parts(plate: plate, data_map: data_map)\n  end\n\n  # Creates a DataAssociation for each entry with Key :part_data and\n  # Value \"well\" (saved as DataAssociation.object)\n  # Each value is associated to its respective key\n  #\n  # @param plate [Collection] the plate that contains the parts (items)\n  # @param data_map [Array\u003cArray\u003cr,c, value, key\u003e, ...\u003e] data map of all parts\n  def associate_value_key_to_parts(plate:, data_map:)\n    data_map.each do |key_value_map|\n      part = plate.part(key_value_map[0], key_value_map[1])\n      data_value = key_value_map[2]\n      key = key_value_map[3]\n      associate_data(part, key.to_sym, data_value) unless part.nil?\n    end\n  end\n\n  # Adds data to list of coordinates\n  # If there is already a data value present, the new data value will\n  # either replace it, or be appended to it\n  # based on the value of the append boolean\n  #\n  # @param coordinates [Array\u003cRow(int), Column(int), Optional(String)] the\n  #       coordinate list to be modified\n  # @param data [String] string to be added to the list data\n  # @param append: [Boolean] default true.  Replace if false\n  def append_x_to_rcx(coordinates, data, append: true)\n    data = data.to_s\n    if coordinates[2].nil? || !append\n      coordinates[2] = data\n    else\n      coordinates[2] += ', ' + data\n    end\n    coordinates\n  end\n\n\n  # Creates an array of samples that are the same in two different Collections\n  #\n  # @param collection_a [Collection] a collection\n  # @param collection_b [Collection] a collection\n  # @return [Array\u003cSample\u003e]\n\n  def find_like_samples(collection_a, collection_b)\n    collection_a.parts.map!(\u0026:sample) \u0026 collection_b.parts.map!(\u0026:sample)\n  end\n\n\n  # Returns an array of parts in the Collection that match the right Sample\n  #\n  # @param collection [Collection] the Collection that the Item (part) is in\n  # @param sample [Sample] the Sample searched for\n\n  def parts_from_sample(collection, sample)\n    part_location = collection.find(sample)\n    parts = []\n    part_location.each do |coordinates|\n      parts.push(collection.part(coordinates[0], coordinates[1]))\n    end\n    parts\n  end\n\n\n  # Adds provenance history to to_object and from from_object\n  #\n  # @param from_obj [Item] object that provenance is coming from\n  # @param to_obj [Item] the object that provenance is going to\n  \n  def from_obj_to_obj_provenance(to_obj, from_obj)\n    raise \"Object #{to_obj.id} is not an item\" unless to_obj.is_a? Item\n    raise \"Object #{from_obj.id} is not an item\" unless from_obj.is_a? Item\n\n    from_obj_map = AssociationMap.new(from_obj)\n    to_obj_map = AssociationMap.new(to_obj)\n    add_provenance(from: from_obj, from_map: from_obj_map,\n                   to: to_obj, to_map: to_obj_map)\n    from_obj_map.save\n    to_obj_map.save\n  end\nend\n"}},{"library":{"name":"CollectionDisplay","category":"Collection_Management","code_source":"# Justin Vrana\n#\n# modified by:\n# Cannon Mallory\n# malloc3@uw.edu\n#\n# Modifications include:\n# Optional Checkable boxes.  Additional Documentation\n\n# Methods for displaying information about collections\nmodule CollectionDisplay\n  # Highlights all non-empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_non_empty(collection, check: true, \u0026rc_block)\n    highlight_collection_rc(collection, collection.get_non_empty,\n                            check: check, \u0026rc_block)\n  end\n\n  # Highlights all empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_empty(collection, check: true, \u0026rc_block)\n    highlight_collection_rc(collection, collection.get_empty,\n                            check: check, \u0026rc_block)\n  end\n\n  # Highlights all non-empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_alpha_non_empty(collection, check: true, \u0026rc_block)\n    highlight_alpha_rc(collection, collection.get_non_empty,\n                       check: check, \u0026rc_block)\n  end\n\n  # Highlights all empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_alpha_empty(collection, check: true, \u0026rc_block)\n    highlight_alpha_rc(collection, collection.get_empty,\n                       check: check, \u0026rc_block)\n  end\n\n  # Gets a list of the coordinates and alphanumeric locations\n  #\n  # @param collection [Collection] the collection that items are going to\n  # @param samples [The samples that locations are wanted from]\n  #\n  # @return [Array\u003cArray\u003crow, column, location\u003e] Coordinates and\n  #      locations in same order as sample array\n  def get_rcx_list(collection, samples)\n    coordinates_and_data = []\n    samples.each do |sample|\n      sample_coordinates = get_obj_location(collection, sample)\n      sample_locations = get_alpha_num_location(collection, sample)\n\n      sample_coordinates.each do |coordinates|\n        coordinates.push(sample_locations) # [0,0,A1]\n        coordinates_and_data.push(coordinates)\n      end\n    end\n  end\n\n  # Highlights all cells listed in rc_list (CHANGED NAME)\n  #\n  # @param collection [Collection] the collection which should be highlighted\n  # @param rc_list [Array] array of rc [[row,col],...]\n  #                       row = int\n  #                       col = int\n  # @param check [Boolean] Optional whether cells should be Checkable\n  # @param \u0026rc_block [Block] to determine rc list\n  # @return [Table]\n  def highlight_collection_rc(collection, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map { |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, '']\n    }\n    highlight_collection_rcx(collection, rcx_list, check: check)\n  end\n\n  # Highlights all cells in ROW/COLUMN/X\n  #\n  #\n  # @param collection [Collection] the collection\n  # @param rcx_list [Array] array of [[row, colum, x],...]\n  #     row = int\n  #     col = int\n  #     x = string\n  # @return [Table]\n  def highlight_collection_rcx(collection, rcx_list, check: true)\n    rows, columns = collection.dimensions\n    table = create_collection_table(rows: rows, columns: columns)\n    highlight_rcx(table, rcx_list, check: check)\n  end\n\n  # Makes an alpha numerical display of collection wells listed in rc_list\n  #\n  # @param collection [Collection] the collection\n  # @param rc_list [Array] Array of rows and columns [[row,col],...]\n  # @param check [Boolean] Default True weather cells are checkable\n  # @param \u0026rc_block [Block] Optional tbd\n  def highlight_alpha_rc(collection, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map { |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, '']\n    }\n    highlight_alpha_rcx(collection, rcx_list, check: check)\n  end\n\n  # Makes an alpha numerical display of collection wells listed in rcx_list\n  #\n  # @param collection [Collection] the collection\n  # @param rc_list [Array] Array of rows and columns [[row,col,x],...]\n  #         row,column are int, x is string\n  # @param check [Boolean] Default True weather cells are checkable\n  # @param \u0026rc_block [Block] Optional tbd\n  def highlight_alpha_rcx(collection, rcx_list, check: true)\n    rows, columns = collection.dimensions\n    tbl = create_collection_table(rows: rows, columns: columns)\n    rcx_list.each do |r, c, x|\n      highlight_cell(tbl, r, c, x, check: check)\n    end\n    tbl\n  end\n\n  # Creates a table with the same dimensions as the input collection\n  #\n  # @param collection [Collection] the collection to be represented by the table\n  # @param add_headers [Boolean] optional True\n  # @return tab [Table] a table to be displayed\n  def create_collection_table(rows:, columns:)\n    size = rows * columns\n    slots = (1..size + rows + columns + 1).to_a\n    tab = slots.each_slice(columns + 1).map do |row|\n      row.map do\n        { class: 'td-empty-slot' }\n      end\n    end\n\n    labels = Array(1...size + 1)\n    tab.each_with_index do |row, row_idx|\n      row.each_with_index do |col, col_idx|\n        if row_idx.zero?\n          col[:content] = \"\u003cb\u003e\u003cu\u003e#{col_idx}\u003c/u\u003e\u003c/b\u003e\"\n        elsif col_idx.zero?\n          col[:content] = \"\u003cb\u003e\u003cu\u003e#{get_alpha(row_idx)}\u003c/u\u003e\u003c/b\u003e\"\n        else\n          col[:content] = labels.first\n          labels = labels.drop(1)\n        end\n      end\n    end\n    tab.first.first[:content] = '\u003cb\u003e:)\u003c/b\u003e'\n    tab\n  end\n\n  # converts numbers to alphabetical values (eg 1-\u003eA 27-AA etc)\n  #\n  # @param num [Integer] the integer to be converted\n  def get_alpha(num)\n    alpha26 = ('A'...'AA').to_a\n    return \"\" if num \u003c 1\n    string = \"\"\n    loop do\n      num, r = (num-1).divmod(26)\n      string.prepend(alpha26[r])\n      break if num.zero?\n    end\n    string\n  end\n\n  # Highlights a specific location in a table (TODO TABLE CLASS)\n  #\n  # @param tbl [Table] the table which parts are being highlighted\n  # @param row [Integer] the row\n  # @param col [Integer] the column\n  # @param id [String] what will be printed in the table\n  #                    (TODO EMPTY STRING/DON'T REPLACE CONTENT)\n  # @param check [Boolean] optional determines if cell is checkable or not\n  def highlight_cell(tbl, row, col, id, check: true)\n    tbl[row + 1][col + 1] = { content: id, class: 'td-filled-slot', check: check }\n  end\n\n  # Highlights all cells in ROW/COLUMN/X  (TODO TABLE CLASS)\n  # X can be any string that is to be displayed in cell\n  #\n  # @param table [table] the table with cells to be highlighted\n  # @param rcx_list [array] array of [[row, column, x],...]\n  #     row = int\n  #     col = int\n  #     x = string\n  # @return [table]\n  def highlight_rcx(table, rcx_list, check: true)\n    rcx_list.each do |rcx|\n      rcx.push(check)\n    end\n    highlight_rcx_check(table, rcx_list)\n    table\n  end\n\n  # Highlights all cells in ROW/COLUMN/X  (TODO TABLE CLASS)\n  # X can be any string that is to be displayed in cell\n  #\n  # @param table [Table] the table with cells to be highlighted\n  # @param rcx_check_list [Array] array of [[row, column, data, check],...]\n  # @return [Table]\n  def highlight_rcx_check(table, rcx_check_list)\n    rcx_check_list.each do |row, column, data, check|\n      highlight_cell(table, row, column, data, check: check)\n    end\n    table\n  end\n\n  # TODO: TABLE LIB\n  # Highlights all cells listed in rc_list\n  #\n  # @param collection [Collection] the collection which should be highlighted\n  # @param rc_list [Array] array of rc [[row,col],...]\n  #                       row = int\n  #                       col = int\n  # @param check [Boolean] true if cells should be Checkable\n  # @param \u0026rc_block [Block] to determine rc list\n  # @return [Table]\n  def highlight_rc(table, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map do |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, \"\"]\n    end\n    highlight_rcx(table, rcx_list, check: check)\n  end\n\n  # Highlights all slots in all collections in operation list\n  #\n  # @param ops [OperationList] Operation list\n  # @param id_block [Block] Optional Unknown\n  # @param check [Boolean] true if cells should be Checkable\n  # @param \u0026fv_block [Block] Optional Unknown\n  # @return [Table]\n  def highlight_collection(ops, id_block: nil, check: true, \u0026fv_block)\n    g = ops.group_by { |op| fv_block.call(op).collection }\n    tables = g.map do |collection, grouped_ops|\n      rcx_list = grouped_ops.map do |op|\n        fv = fv_block.call(op)\n        id = id_block.call(op) if id_block\n        id ||= fv.sample.id\n        [fv.row, fv.column, id]\n      end\n      tbl = highlight_collection_rcx(collection, rcx_list, check: check)\n      [collection, tbl]\n    end\n    tables\n  end\n\n  # TODO: write highlight heat map method for table\n  # Creates table illustrating data associated with keys\n  #  for each part noted in rc_list\n  #\n  # @param collection [Collection] the collection\n  # @param keys [Array\u003cString\u003e] an array of all keys that point to desired data\n  # @param rc_list [Array\u003cArray\u003crow, col\u003e...\u003e] optional array of locations\n  #        if not given will display all non_empty\n  # @return table of parts with data information\n  def display_data(collection, keys, rc_list: nil)\n    if rc_list.nil?\n      rc_list = collection.get_non_empty\n    end\n    rcx_array = []\n    rc_list.each do |loc|\n      data_string = ''\n      keys.each_with_index do |key, idx|\n        part = collection.part(loc[0], loc[1])\n        data = get_associated_data(part, key).to_s\n        unless data.nil?\n          data_string += ', ' unless idx.zero?\n          data_string += data\n        end\n      end\n      loc.push(data_string)\n      rcx_array.push(loc)\n    end\n    highlight_collection_rcx(collection, rcx_array, check: false)\n  end\nend\n"}},{"library":{"name":"CollectionLocation","category":"Collection_Management","code_source":"# frozen_string_literal: true\n\n# Cannon Mallory\n# malloc3@uw.edu\n#\n# Methods to facilitate sample management within collections\nmodule CollectionLocation\n  ALPHA26 = ('A'...'Z').to_a\n\n  # Gets the location string of a sample in a collection\n  #\n  # @param collection [Collection] the collection containing the sample\n  # @param sample [Sample] the Sample that you want to locate\n  # @return [Hash{sample: location}] the Alpha Numeric location(s) e.g. A1, A2\n  def get_alpha_num_location(collection, items)\n    items = [items] unless items.is_a?(Array)\n\n    hash_of_samples = {}\n    items.each do |sample|\n      coordinates = collection.find(sample)\n      alpha_num_locations = []\n      coordinates.each do |coordinate_set|\n        alpha_num_locations \u003c\u003c convert_coordinates_to_location(coordinate_set)\n      end\n      locations.join(',')\n      hash_of_samples[sample] = locations\n    end\n    hash_of_samples\n  end\n\n  # Converts an array of coordinates to alpha numerical locations\n  #\n  # @param coordinates [Array\u003crow,column\u003e] set of coordinates\n  # @return [String] alpha numerical location\n  def convert_coordinates_to_location(coordinates)\n    ALPHA26[coordinates[0]] + (coordinates[1] + 1).to_s\n  end\n\n  # Converts alpha numerical location to an Array of coordinates\n  #\n  # @param alpha [String] alpha numerical location\n  # @return [Array\u003cr,c\u003e] array of row and column\n  def convert_location_to_coordinates(alpha)\n    alpha_characters = ''\n    alpha.length.times do |idx|\n      char = alpha[idx, idx+1]\n      alpha_characters += char unless float(char).nil?\n    end\n    row = ALPHA26.find_index(alpha_characters)\n    column = alpha[1..-1].to_i - 1\n    [row, column]\n  end\n\n  # Finds the location coordinates of an multiple items/samples\n  #\n  # @param collection [Collection] the Collection containing the Item or Sample\n  # @param items [Array\u003cobjects\u003e] Item, Part, or Sample to be found\n  # @return [Hash{sample: [row, column]}] \n  def get_items_coordinates(collection, items)\n    hash_of_locations = {}\n    items.each do |item|\n      hash_of_locations[item] = collection.find(item)\n    end\n    hash_of_locations\n  end\n\n  # Finds a part from an alpha numerical string location(e.g. A1, B1)\n  #  TODO Move to krill\n  #\n  # @param collection [Collection] the collection that contains the part\n  # @param location [String] the location of the part within the collection\n  # @return part [Item] the item at the given location\n  def get_part(collection, location)\n    row, column = convert_location_to_coordinates(location)\n    collection.part(row, column)\n  end\nend\n"}},{"library":{"name":"CollectionTransfer","category":"Collection_Management","code_source":"# Cannon Mallory\n# malloc3@uw.edu\n#\n# Methods for transferring items into and out of collections\n\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/AssociationManagement'\nneeds 'Collection_Management/CollectionLocation'\nneeds 'Collection_Management/CollectionData'\n\nmodule CollectionTransfer\n  include Units\n  include Debug\n  include AssociationManagement\n  include CollectionLocation\n  include CollectionData\n\n  VOL_TRANSFER = 'Volume Transferred'.to_sym\n\n  # gets the number of plates\n  #\n  # @param operations [OperationList] list of operations in job\n  # @param role [String] indicates whether it's an input or output collection\n  # @returns Array[collection] the number of plates\n  def get_array_of_collections(operations, role)\n    collection_array = []\n    operations.each do |op|\n      obj_array = op.inputs if role == 'input'\n      obj_array = op.outputs if role == 'output'\n      obj_array.each do |fv|\n        collection_array.push(fv.collection) unless fv.collection.nil?\n      end\n    end\n    collection_array.uniq\n  end\n\n  # Determines if there are multiple plates\n  #\n  # @param operations [OperationList] list of operations in job\n  # @param role [String], whether plates are for input or output\n  # @returns boolean true if multiple plates\n  def multiple_plates?(operations, role: 'input')\n    return true if get_num_plates(operations, role) \u003e 1\n  end\n\n  # gets the number of plates\n  #\n  # @param operations [OperationList] list of operations in job\n  # @param role [String] indicates whether it's an input or output collection\n  # @returns [Int] the number of plates\n  def get_num_plates(operations, role)\n    get_array_of_collections(operations, role).length\n  end\n\n\n\n  # Transfers samples from fv_array to collection.  If the collection cannot\n  # hold all the samples it will create more collections to hold all samples.\n  # Will automatically populate the collection\n  #\n  # fv_array can be of items in collections or not doesn't matter\n  #\n  #\n  # Optional: Can provide instructions for transferring samples to collections\n  #\n  # Samples can be either FieldValue or Item/Part\n  # Groups samples by collection for easier transfer\n  # Uses transfer_to_to_collection method\n  #\n  # @param input_fv_array [Array\u003cFieldValues\u003e] an array of field values\n  # @param to_collection [Collection] Should have samples already associated\n  # @param transfer_vol [Int] volume in sample to transfer\n  def transfer_subsamples_to_working_plate(fv_array, to_collection: nil, \n                                      collection_type: nil, transfer_vol: nil,\n                                      instructions: true, add_column_wise: false)\n\n    grouped_fv_array = fv_array.group_by{|fv| fv.part?}\n    collections = []\n    grouped_fv_array.each do |is_part, sub_fv_array|\n      if is_part\n        collections += transfer_collection_to_collection(sub_fv_array, \n                                        to_collection: to_collection,\n                                        collection_type: collection_type,\n                                        transfer_vol: transfer_vol,\n                                        instructions: instructions,\n                                        add_column_wise: add_column_wise)\n      else\n        collections += transfer_items_to_collection(sub_fv_array, \n                                          to_collection: to_collection,\n                                          collection_type: collection_type,\n                                          transfer_vol: transfer_vol,\n                                          instructions: instructions,\n                                          add_column_wise: add_column_wise)\n      end\n    end\n    collections.uniq\n  end\n\n\n  # Handles transfers of items from one collection to another collection\n  #\n  # If an 'association_map' is given 'to_collection' must also be given\n  #  it will assume that the plate is already plated.\n  #  'array_of_samples', 'one_to_one', and 'populate_collection' will be ignored\n  #\n  # If array_of_samples is not given then it will be assumed that all samples\n  #   should transferred.\n  # \n  #\n  # @param input_collection [Collection] the collection samples come from\n  # @param to_collection[Collection] the collection samples will move to\n  # @param transfer_vol [String] volume of sample to transfer (INCLUDE UNITS)\n  # @param populate_collection [Boolean] true if the to_collection needs to be\n  #        populated false if the to_collection has already been populated.\n  # @param array_of_samples [Array\u003cSample\u003e] Optional\n  # @param instructions [Boolean] default true to include instructions\n  # @param association_map [Array\u003c{to_loc: [r, c], from_loc: [r, c]}, ...\u003e]\n  #        a map showing the associations from one collection to another.\n  def transfer_from_collection_to_collection(from_collection, \n                                             to_collection: nil,\n                                             collection_type: nil,\n                                             transfer_vol: nil,\n                                             populate_collection: true,\n                                             array_of_samples: nil,\n                                             instructions: true,\n                                             one_to_one: false,\n                                             association_map: nil,\n                                             column_wise: false)\n    collections, association_maps = determine_collections_and_association_map(from_collection, \n                                                                to_collection: to_collection,\n                                                                collection_type: collection_type,\n                                                                populate_collection: populate_collection,\n                                                                array_of_samples: array_of_samples,\n                                                                instructions: instructions,\n                                                                one_to_one: one_to_one,\n                                                                association_map: association_map,\n                                                                add_column_wise: column_wise)\n\n    collections.each_with_index do |collection, idx|\n      association_map = association_maps[idx]\n      associate_plate_to_plate(to_collection: collection, from_collection: from_collection,\n                              association_map: association_map, transfer_vol: transfer_vol)\n      if instructions\n        collection_to_collection_transfer_instructions(to_collection: collection, from_collection: from_collection,\n                                       association_map: association_map, transfer_vol: transfer_vol)\n      end\n    end\n    collections\n  end\n\n\n\n  # TODO Break this apart\n  # Assists with transfer of items into a collection\n  # Optional Instructions to tech\n  #\n  # @param fv_array [Array\u003citem or field values\u003e] the samples to be transferred\n  #\n  # @param to_collection [Collection] (optional)\n  # @param collection_type [String] (optional)\n  #    NOTE: exactly one to_collection or collection_type must be given\n  #\n  # @param transfer_volume [Float] the volume that is to be transferred\n  # @param instructions [Boolean] true if instructions are to be displayed\n  #\n\n  # @param association_map [Array\u003c{to_loc: [row, col], from_loc: item},...\u003e]\n  #        if a map is given then the plate is assumed to be populated already\n  #\n  # @return collections [Array\u003cCollections\u003e] the collections created/used\n  def transfer_items_to_collection(fv_array, to_collection: nil,\n                                             collection_type: nil,\n                                             transfer_vol: nil,\n                                             instructions: true,\n                                             association_map: nil,\n                                             add_column_wise: false)\n    sample_array = fv_array.map(\u0026:sample)\n    array_of_association_maps = []\n    collections = []\n\n    if association_map.nil?\n      collections = make_and_populate_collection(sample_array,\n                                            first_collection: to_collection,\n                                            collection_type: collection_type,\n                                            label_plates: instructions,\n                                            add_column_wise: add_column_wise)\n      collections.each do |collection|\n        association_map = make_item_to_collection_association_map(sample_array,\n                                                        collection: collection)\n        array_of_association_maps.push(association_map)\n      end\n    else\n      ProtocolError 'Must Give to_collection' if to_collection.nil?\n      array_of_association_maps.push(association_map)\n      collections.push(to_collection)\n    end\n\n    array_of_association_maps.each_with_index do |map, idx|\n      collection = collections[idx]\n      associate_items_to_wells(to_collection: collection, association_map: map,\n                                                    transfer_vol: transfer_vol)\n      next unless instructions\n\n\n      item_to_collection_transfer_instructions(to_collection: collection,\n                                               association_map: map,\n                                               transfer_vol: transfer_vol)\n    end\n    collections\n  end\n\n  # Assist with the transfer from a collection to an item.\n  # An association map must first be created\n  #\n\n  # @param from_collection [Collection] the collection that is being transferred\n  # @param association_map [Array\u003c{to_loc: item, from_loc: [row, col]}, ...\u003e]\n  # @param transfer_vol [String/Int] the volume being transferred\n  # @param instructions [Boolean] optional instructions\n  def transfer_from_collection_to_items(from_collection:, association_map:,\n                                                          transfer_vol: nil,\n                                                          instructions: true)\n    associate_wells_to_item(from_collection: from_collection, association_map: association_map,\n                            transfer_vol: transfer_vol)\n    next unless instructions\n\n    collection_to_items_transfer_instructions(from_collection: from_collection,\n                                              association_map: association_map,\n                                              transfer_vol: transfer_vol)\n  end\n\n  # Instructions on relabeling plates to new plate ID\n  # Tracks provenance properly though transfer\n  #\n  # @param plate1 [Collection] plate to relabel\n  # @param plate2 [Collection] new plate label\n  def relabel_plate(from_collection, to_collection: nil)\n    collection_type = nil\n\n    collection_type = from_collection.object_type.name if to_collection.nil?\n\n    unless from_collection.object_type == to_collection.object_type\n      ProtocolError 'Object Types do not match'\n    end\n\n    relabeled_collection = transfer_from_collection_to_collection(from_collection,\n                                                to_collection: to_collection,\n                                                collection_type: collection_type,\n                                                instructions: false,\n                                                one_to_one: true,\n                                                add_column_wise: false).first\n    show do\n      title 'Rename Plate'\n      note \"Relabel plate \u003cb\u003e#{from_collection.id}\u003c/b\u003e with\n                        \u003cb\u003e#{relabeled_collection.id}\u003c/b\u003e\"\n    end\n    to_collection\n  end\n\n\n  # To offload work from transfer_from_collection_to_collection\n  # Handles large if else cases and returns collections and association maps\n  def determine_collections_and_association_map(from_collection, \n                                                to_collection: nil,\n                                                collection_type: nil,\n                                                populate_collection: true,\n                                                array_of_samples: nil,\n                                                instructions: true,\n                                                one_to_one: false,\n                                                association_map: nil,\n                                                add_column_wise: false)\n    association_maps = []\n    collections = []\n    if !association_map.nil?\n      raise 'to_collection not given' if to_collection.nil?\n\n      collections.push(to_collection)\n      association_maps.push(association_map)\n    elsif one_to_one\n      unless array_of_samples.nil?\n        raise 'array_of_samples cannot ge given if one_to_one'\n      end\n\n\n      if populate_collection || to_collection.nil?\n        # TODO this may not work as expected....  need to think about this\n        array_of_samples = get_samples_from_obj(from_collection.parts)\n\n        collections = make_and_populate_collection(array_of_samples, \n                                                first_collection: to_collection,\n                                                collection_type: collection_type,\n                                                label_plate: instructions,\n                                                add_column_wise: false)\n      else\n        collections = [to_collection]\n      end\n      association_map = make_one_to_many_association_map(\n                                                  to_collection: collection,\n                                                  from_collection: from_collection,\n                                                  samples: nil,\n                                                  one_to_one: true)\n      association_maps.push(association_map)\n    else\n      if array_of_samples.nil?\n        array_of_samples = get_samples_from_obj(from_collection.parts)\n      end\n\n\n      array_of_samples.map! do |object| \n        if object.is_a? Sample\n          object\n        else\n          object = object.sample\n        end\n      end      \n      if populate_collection || to_collection.nil?\n        collections = make_and_populate_collection(array_of_samples, \n                                                first_collection: to_collection,\n                                                collection_type: collection_type,\n                                                label_plates: instructions)\n      else\n        collections = [to_collection]\n      end\n\n      collections.each do |collection|\n        association_map = make_one_to_many_association_map(\n                                            to_collection: collection,\n                                            from_collection: from_collection,\n                                            samples: array_of_samples,\n                                            one_to_one: one_to_one)\n        association_maps.push(association_map)\n      end\n    end\n    [collections, association_maps]\n  end\n\n  def get_samples_from_obj(array)\n    array.map do |part|\n      return part.sample unless part.is_a? Sample\n\n      part\n    end\n    array\n  end\n\n  # @warning Use transfer_subsamples_to_working_plate instead\n  #\n  # @param fv_array Array\u003cFieldValues\u003e] an array of field values of collections\n  # @param to_collection [Collection]\n  # @param transfer_vol [String/Int] volume in sample to transfer\n  # @param instructions [Boolean] true if instructions are to be shown\n  def transfer_collection_to_collection(fv_array, to_collection: nil, \n                                                  collection_type: nil, \n                                                  transfer_vol: nil,\n                                                  instructions: nil, \n                                                  add_column_wise: false)\n    collections = []\n    sample_array_by_collection = fv_array.group_by { |fv| fv.collection }\n    sample_array_by_collection.each do |from_collection, fv_array|\n      sample_array = fv_array.map { |fv| fv.sample }\n      collections = transfer_from_collection_to_collection(from_collection, \n                                               to_collection: to_collection,\n                                               collection_type: collection_type,\n                                               transfer_vol: transfer_vol,\n                                               array_of_samples: sample_array,\n                                               instructions: instructions)\n    end\n    collections\n  end\n\n\n  # Transfer instructions for tech\n  #\n\n  # @param to_collection [Collection] the to collection\n  # @param from_collection [Collection] the from collection\n  # @param association_map [Array\u003c{to_loc: loc, from_loc: loc}, ...\u003e] optional\n  #         if nil will assume one-to-one\n  # @param transfer_vol [String] Optional else all\n  def collection_to_collection_transfer_instructions(to_collection:,\n                                                     from_collection:,\n                                                     association_map: nil,\n                                                     transfer_vol: nil)\n    if transfer_vol.nil?\n      amount_to_transfer = 'everything'\n    else\n        amount_to_transfer = {transfer_vol}.to_s\n    end\n\n\n    if association_map.nil?\n      association_map = one_to_one_association_map(to_collection: to_collection,\n                                              from_collection: from_collection)\n    end\n\n    from_rcx = []\n    to_rcx = []\n\n    association_map.each do |loc_hash|\n      from_location = loc_hash[:from_loc]\n      to_location = loc_hash[:to_loc]\n      from_alpha_location = convert_coordinates_to_location(to_location)\n      from_rcx.push(append_x_to_rcx(from_location, from_alpha_location))\n      to_rcx.push(append_x_to_rcx(to_location, from_alpha_location))\n    end\n\n    show do\n      title 'Transfer from one plate to another'\n      note \"Please transfer \u003cb\u003e#{amount_to_transfer}\u003c/b\u003e from Plate\n          (\u003cb\u003eID:#{from_collection.id}\u003c/b\u003e) to plate\n          (\u003cb\u003eID:#{to_collection.id}\u003c/b\u003e) per tables below\"\n      separator\n      note \"Stock Plate (ID: \u003cb\u003e#{from_collection.id}\u003c/b\u003e):\"\n      table highlight_collection_rcx(from_collection, from_rcx,\n                                     check: false)\n      note \"Working Plate (ID: \u003cb\u003e#{to_collection}\u003c/b\u003e):\"\n      table highlight_collection_rcx(to_collection, to_rcx,\n                                     check: false)\n    end\n  end\n\n    # (Verified)\n    # Instructions to transfer items to wells of a collection\n    #\n    # @param to_collection [Collection] the plate that is getting the association\n    # @param from_item [item] the item that is transferring the association\n    # @param Association_map [Array\u003c{to_loc: loc, from_loc: item}\u003e] \n    #     Association map of where items are coming from.\n    #     If nil will assume transferred to all wells.\n    # @param transfer_vol [Integer] the volume transferred if applicable default\n    #         nil if nil then will state unknown transfer vol\n    def item_to_collection_transfer_instructions(to_collection:, association_map: nil,\n      transfer_vol: nil)\n      if transfer_vol.nil?\n        amount_to_transfer = \"everything\"\n      else\n        amount_to_transfer = \"#{transfer_vol}\"\n      end\n      list_of_items = [to_collection]\n      rcx_list = []\n      association_map.each do |map|\n        to_location = map[:to_loc]\n        convert_location_to_coordinates(to_location) if to_location.is_a? String\n\n\n        from_item = map[:from_loc]\n        from_item = Item.find(from_item) unless from_item.is_a? Item\n        list_of_items.push(from_item)\n\n        rcx_list.push([to_location[0], to_location[1], from_item.id])\n      end\n\n      show do\n        title \"Get items for transfer\"\n        note 'Please get the following items'\n        table create_location_table(list_of_items)\n      end\n\n\n      show do\n        title 'Transfer from items to the plate'\n        note \"Please transfer \u003cb\u003e#{amount_to_transfer}\u003c/b\u003e from the items \n              listed to Plate #{to_collection.id}\"\n        separator\n        note \"Plate (ID: \u003cb\u003e#{to_collection.id}\u003c/b\u003e):\"\n        table highlight_collection_rcx(to_collection, rcx_list,\n                                      check: true)\n      end\n    end\n\n    # Verified\n    # Instructions to transfer from wells in a collection to items\n    #\n    # @param to_collection [Collection] the plate that is getting the association\n    # @param from_item [item] the item that is transferring the association\n    # @param Association_map [Array\u003c{to_loc: loc, from_loc: item}\u003e] \n    #     If nil will assume transferred to all wells.\n    # @param transfer_vol [Integer] the volume transferred if applicable default\n    #   nil if nil then will state unknown transfer vol\n    def collection_to_items_transfer_instructions(from_collection:,\n                                                  association_map: nil,\n                                                  transfer_vol: nil)\n      if transfer_vol.nil?\n        amount_to_transfer = \"everything\"\n      else\n        amount_to_transfer = \"#{transfer_vol}\"\n      end\n      list_of_items = [to_collection]\n      rcx_list = []\n\n      association_map.each do |map|\n        from_location = map[:from_loc]\n\n        if from_location.is_a? String\n          convert_location_to_coordinates(from_location)\n        end\n\n        to_item = map[:to_loc]\n        to_item = Item.find(to_item) unless to_item.is_a? Item\n        list_of_items.push(to_item)\n\n        rcx_list.push([from_location[0], from_location[1], to_item.id])\n      end\n\n\n      show do\n        title \"Get items for transfer\"\n        note 'Please get the following items'\n        table create_location_table(list_of_items)\n      end\n\n\n      show do\n        title 'Transfer from one plate to another'\n        note \"Please transfer \u003cb\u003e#{amount_to_transfer}\u003c/b\u003e from Plate \n              #{from_collection.id} to the items listed\"\n        separator\n        note \"Plate (ID: \u003cb\u003e#{from_collection.id}\u003c/b\u003e):\"\n        table highlight_collection_rcx(from_collection, rcx_list,\n                                      check: true)\n      end\n    end\n\n    # Creates an association map of items to a collection (verified)\n    #\n    # @param fv_array [Array\u003cFieldValue or Items\u003e] field values or items\n    # @param collection [to_collection] the collection that things are in\n    # @return [Array\u003c{to_loc: location, from_loc: location}, ...]\n    def make_item_to_collection_association_map(fv_array, collection:)\n      association_map = []\n      fv_array.each do |item|\n        item = item.item if item.is_a? FieldValue\n        unless item.is_a? Sample\n          item = item.sample\n        end\n\n        to_location = collection.find(item)\n        to_location.each do |loc|\n          ProtocolError 'Wrong Loc format' unless loc.is_a? Array\n          from_location = item.id\n          unless loc.nil?\n            association_map.push({to_loc: loc, from_loc: from_location})\n          end\n        end\n      end\n      association_map\n    end\n\n\n    # Tracks provenance and adds transfer vol association\n    # for item to well transfers\n    #\n    #\n    # @param to_collection [Collection] the plate that is getting the association\n    # @param from_item [item] the item that is transferring the association\n    # @param Association_map [Array\u003c{to_loc: loc, from_loc: item},...\u003e]\n    #     If nil will assume transferred to all wells.\n    #     Can take standard Array of Hashes as used in other methods in this\n    #       library\n    # @param transfer_vol [Integer] the volume transferred if applicable default\n    #   nil if nil then will state unknown transfer vol\n    def associate_items_to_wells(to_collection:, association_map: nil,\n                                transfer_vol: nil)\n      association_map.each do |map|\n        to_loc = map[:to_loc]\n        from_item = map[:from_loc]\n        from_item = Item.find(from_item) unless from_item.is_a? Item\n\n        to_part = to_collection.part(to_loc[0], to_loc[1])\n\n        unless transfer_vol.nil?\n          associate_transfer_vol(transfer_vol, VOL_TRANSFER, to_part: to_part,\n                                                            from_part: from_item)\n        end\n        from_obj_to_obj_provenance(to_part, from_item)\n      end\n    end\n\n    # Creates data association based on plate map for transfer\n    # Additionally tracks provenance through items.\n    #\n    #\n    # @param from_collection [Collection] the is transferring the association\n    # @param to_item [item] the item that is getting_the association\n    # @param Association_map [Array\u003cHash{to_loc: item, from_loc: [row, col]}, ...] \n    #      Association map of where items are coming from and going to.\n    # @param transfer_vol [String] the volume transferred if applicable\n    def associate_wells_to_item(from_collection:, association_map: nil,\n                                transfer_vol: nil)\n      association_map.each do |map|\n        from_loc = map[:from_loc]\n        if from_loc.is_a? String\n          from_loc = convert_location_to_coordinates(from_loc)\n        end\n\n        from_part = from_collection.part(from_loc[0], from_loc[1])\n        to_item = map[:to_loc]\n        to_item = Item.find(to_item) unless to_item.is_a? Item\n\n        unless transfer_vol.nil?\n          associate_transfer_vol(transfer_vol, VOL_TRANSFER,\n                                              to_part: to_item,\n                                              from_part: from_part)\n        end\n        from_obj_to_obj_provenance(to_item, from_part)\n      end\n    end\n\n\n    # Makes proper association_map between to_collection and from_collection\n    #\n    # @param to_collection [Collection] the collection that things are moving to\n    # @param from_collection [Collection] the collection that things are coming from\n    # @param samples [Array\u003c{to_loc: loc, from_loc: loc}\u003e] array of samples that\n    #             exists in both collections\n    # @param one_to_one [Boolean] if true then will make an exact one to one transfer\n    #         else creates map based on \"similar\" samples\n    def make_one_to_many_association_map(to_collection:, from_collection:, \n                                         samples: nil, one_to_one: false)\n      if one_to_one\n        return one_to_one_association_map(to_collection: to_collection, \n                                          from_collection: from_collection)\n      end\n\n\n      if samples.nil?\n        samples = find_like_samples(to_collection, from_collection)\n      end\n      # Array\u003c{to_loc: loc, from_loc: loc}\n\n      association_map = []\n      samples_with_no_location = []\n\n      samples.each do |sample|\n        to_loc = to_collection.find(sample)\n        from_loc = from_collection.find(sample)\n        # TODO: figure out how the associations will work if there are multiple\n        # to and from locations (works partially may could use improvement)\n\n        if to_loc.nil? || from_loc.nil?\n          samples_with_no_location.push(sample)\n        end\n\n        if from_loc.length == 1\n          to_loc.each do |t_loc|\n            association_map.push({ to_loc: t_loc, from_loc: from_loc.first })\n          end\n        else\n          from_loc.each do |from_loc|\n            match = false\n            to_loc.each do |to_loc|\n              if to_loc[0] == from_loc[0] \u0026\u0026 to_loc[1] == from_loc[1]\n                match = true\n                association_map.push({ to_loc: to_loc, from_loc: from_loc })\n              end\n            end\n            ProtocolError \"AssociationMap was not properly created.\" unless match\n            # TODO: Create a better error handle here \n            # (make it so it shows them the issue more explicitly)\n          end\n        end\n        association_map\n      end\n\n      unless samples_with_no_location.length == 0\n        cancel_plan = show do\n          title 'Some Samples were not found'\n          warning 'Some samples there were expected were \n                        not found in the given plates'\n          note 'The samples that could not be found are listed below'\n          select ['Cancel', 'Continue'], var: 'cancel',\n                  label: 'Do you want to cancel the plan?', default: 1\n          samples_with_no_location.each do |sample|\n            note \"#{sample.id}\"\n          end\n        end\n\n        # TODO: Fail softly/continue with samples that were found\n        if cancel_plan[:'cancel'] == 'Cancel'\n          raise 'User Canceled plan because many samples could not be found'\n        else\n          raise \"This module doesn't currently support \n                                continuing with existing samples\"\n        end\n      end\n\n      association_map\n    end\n\n    # Creates a one to one association map\n    #\n    # @param to_collection [Collection] the to collection\n    # @param from_collection [Collection] the from collection\n    # @param samples [Array\u003c{to_loc: loc, from_loc: loc}, ...\u003e]\n    def one_to_one_association_map(to_collection:, from_collection:)\n      to_row_dem, to_col_dem = to_collection.dimensions\n      from_row_dem, from_col_dem = from_collection.dimensions\n      unless to_row_dem == from_row_dem \u0026\u0026 to_col_dem == from_col_dem\n        ProtocolError \"Collection Dimensions do not match\"\n      end\n\n      association_map = []\n      to_row_dem.times do |row|\n        to_col_dem.times do |col|\n          unless to_collection.part(row, col).nil? || \n                          from_collection.part(row, col).nil?\n            loc = [row, col]\n            association_map.push({ to_loc: loc, from_loc: loc })\n          end\n        end\n      end\n      association_map\n    end\n\n\n    # Creates Data Association between to_collection and from_collection\n    #\n    # @param to_collection [Collection] the to collection\n    # @param from_collection [Collection] the from collection\n    # @param Association_map [Array\u003cHash\u003cfrom_loc: loc1, to_loc: loc2\u003e]\n    #             optional Association map else one_to_one\n    # @param transfer_vol [Integer] the volume transferred else all\n    def associate_plate_to_plate(to_collection:, from_collection:, \n                                 association_map: nil, transfer_vol: nil)\n      # if there is no association map assume one_to_one\n      if association_map.nil?\n        association_map = one_to_one_association_map(\n                                                to_collection: to_collection,\n                                                from_collection: from_collection)\n      end\n\n      from_obj_to_obj_provenance(to_collection, from_collection)\n\n      association_map.each do |loc_hash|\n        to_loc = loc_hash[:to_loc]\n        from_loc = loc_hash[:from_loc]\n\n        to_loc = convert_location_to_coordinates(to_loc) if to_loc.is_a? String\n        if from_loc.is_a? String\n          from_loc = convert_location_to_coordinates(from_loc)\n        end\n\n        to_part = to_collection.part(to_loc[0], to_loc[1])\n        from_part = from_collection.part(from_loc[0], from_loc[1])\n\n        unless transfer_vol.nil?\n        associate_transfer_vol(transfer_vol, VOL_TRANSFER, to_part: to_part,\n                                                          from_part: from_part)\n      end\n\n      from_obj_to_obj_provenance(to_part, from_part)\n    end\n  end\n\n  # Records the volume transferred\n  #\n  # @param vol the volume transferred\n  # @param to_part: part that is being transferred to\n  # @param from_part: part that is being transferred from\n  def associate_transfer_vol(vol, key, to_part:, from_part:)\n    vol_transfer_array = get_associated_data(to_part, key)\n    vol_transfer_array = [] if vol_transfer_array.nil?\n    vol_transfer_array.push([from_part.id, vol])\n    associate_data(to_part, key, vol_transfer_array)\n  end\nend #end of CollectionManagement"}}]}